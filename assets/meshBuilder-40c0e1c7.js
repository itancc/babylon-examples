import{L as T,V as I,jK as p,q as S,n as N,a4 as U,J as j,cP as R,gM as X,M as Y,K as E,B as q,dL as H,F as k,au as K,dp as J,dA as Q,w as _,dR as $,dS as ee,dt as te,N as se,dc as oe,fr as ne,fs as ae,ds as ie,dP as re,a3 as ce,dj as he,dN as le,dk as fe,dw as de,fq as xe,dV as Ae,de as ue,I as ye,dJ as Be}from"./renderLoop-11076d74.js";class v{constructor(t=0,e=0){this.x=t,this.y=e,t!==Math.floor(t)&&T.Warn("x is not an integer, floor(x) used"),e!==Math.floor(e)&&T.Warn("y is not an integer, floor(y) used")}clone(){return new v(this.x,this.y)}rotate60About(t){const e=this.x;return this.x=t.x+t.y-this.y,this.y=e+this.y-t.x,this}rotateNeg60About(t){const e=this.x;return this.x=e+this.y-t.y,this.y=t.x+t.y-e,this}rotate120(t,e){t!==Math.floor(t)&&T.Warn("m not an integer only floor(m) used"),e!==Math.floor(e)&&T.Warn("n not an integer only floor(n) used");const o=this.x;return this.x=t-o-this.y,this.y=e+o,this}rotateNeg120(t,e){t!==Math.floor(t)&&T.Warn("m is not an integer, floor(m) used"),e!==Math.floor(e)&&T.Warn("n is not an integer,   floor(n) used");const o=this.x;return this.x=this.y-e,this.y=t+e-o-this.y,this}toCartesianOrigin(t,e){const o=I.Zero();return o.x=t.x+2*this.x*e+this.y*e,o.y=t.y+Math.sqrt(3)*this.y*e,o}static Zero(){return new v(0,0)}}class W{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new Z("icosahedron","Regular",[[0,p,-1],[-p,1,0],[-1,0,-p],[1,0,-p],[p,1,0],[0,p,1],[-1,0,p],[-p,-1,0],[0,-p,-1],[p,-1,0],[1,0,p],[0,-p,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let t=12;const e={},o=this.m,s=this.n;let i=o,n=1,r=0;s!==0&&(i=S.HCF(o,s)),n=o/i,r=s/i;let h,f,y,g,x;const w=v.Zero(),A=new v(o,s),B=new v(-s,o+s),u=v.Zero(),D=v.Zero(),O=v.Zero();let b=[],l,a,c,V;const z=[],d=this.vertByDist,F=(C,m,G,L)=>{l=C+"|"+G,a=m+"|"+L,l in e||a in e?l in e&&!(a in e)?e[a]=e[l]:a in e&&!(l in e)&&(e[l]=e[a]):(e[l]=t,e[a]=t,t++),d[G][0]>2?z[e[l]]=[-d[G][0],d[G][1],e[l]]:z[e[l]]=[b[d[G][0]],d[G][1],e[l]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let C=0;C<20;C++){if(b=this.IDATA.face[C],y=b[2],g=b[1],x=b[0],c=w.x+"|"+w.y,l=C+"|"+c,l in e||(e[l]=y,z[y]=[b[d[c][0]],d[c][1]]),c=A.x+"|"+A.y,l=C+"|"+c,l in e||(e[l]=g,z[g]=[b[d[c][0]],d[c][1]]),c=B.x+"|"+B.y,l=C+"|"+c,l in e||(e[l]=x,z[x]=[b[d[c][0]],d[c][1]]),h=this.IDATA.edgematch[C][0],f=this.IDATA.edgematch[C][1],f==="B")for(let m=1;m<i;m++)D.x=o-m*(n+r),D.y=s+m*n,O.x=-m*r,O.y=m*(n+r),c=D.x+"|"+D.y,V=O.x+"|"+O.y,F(C,h,c,V);if(f==="O")for(let m=1;m<i;m++)O.x=-m*r,O.y=m*(n+r),u.x=m*n,u.y=m*r,c=O.x+"|"+O.y,V=u.x+"|"+u.y,F(C,h,c,V);if(h=this.IDATA.edgematch[C][2],f=this.IDATA.edgematch[C][3],f&&f==="A")for(let m=1;m<i;m++)u.x=m*n,u.y=m*r,D.x=o-(i-m)*(n+r),D.y=s+(i-m)*n,c=u.x+"|"+u.y,V=D.x+"|"+D.y,F(C,h,c,V);for(let m=0;m<this.vertices.length;m++)c=this.vertices[m].x+"|"+this.vertices[m].y,l=C+"|"+c,l in e||(e[l]=t++,d[c][0]>2?z[e[l]]=[-d[c][0],d[c][1],e[l]]:z[e[l]]=[b[d[c][0]],d[c][1],e[l]])}this.closestTo=z,this.vecToidx=e}calcCoeffs(){const t=this.m,e=this.n,o=Math.sqrt(3)/3,s=t*t+e*e+t*e;this.coau=(t+e)/s,this.cobu=-e/s,this.coav=-o*(t-e)/s,this.cobv=o*(2*t+e)/s}createInnerFacets(){const t=this.m,e=this.n;for(let o=0;o<e+t+1;o++)for(let s=this.min[o];s<this.max[o]+1;s++)s<this.max[o]&&s<this.max[o+1]+1&&this.innerFacets.push(["|"+s+"|"+o,"|"+s+"|"+(o+1),"|"+(s+1)+"|"+o]),o>0&&s<this.max[o-1]&&s+1<this.max[o]+1&&this.innerFacets.push(["|"+s+"|"+o,"|"+(s+1)+"|"+o,"|"+(s+1)+"|"+(o-1)])}edgeVecsABOB(){const t=this.m,e=this.n,o=new v(-e,t+e);for(let s=1;s<t+e;s++){const i=new v(this.min[s],s),n=new v(this.min[s-1],s-1),r=new v(this.min[s+1],s+1),h=i.clone(),f=n.clone(),y=r.clone();h.rotate60About(o),f.rotate60About(o),y.rotate60About(o);const g=new v(this.max[h.y],h.y),x=new v(this.max[h.y-1],h.y-1),w=new v(this.max[h.y-1]-1,h.y-1);(h.x!==g.x||h.y!==g.y)&&(h.x!==x.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,x,w]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,w,g])):h.y===y.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([i,n,x]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([i,x,r])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([i,n,x]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,x,g])))}}mapABOBtoOBOA(){const t=new v(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const o=[];for(let s=0;s<3;s++)t.x=this.isoVecsABOB[e][s].x,t.y=this.isoVecsABOB[e][s].y,this.vertexTypes[e][s]===0&&t.rotateNeg120(this.m,this.n),o.push(t.clone());this.isoVecsOBOA.push(o)}}mapABOBtoBAOA(){const t=new v(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const o=[];for(let s=0;s<3;s++)t.x=this.isoVecsABOB[e][s].x,t.y=this.isoVecsABOB[e][s].y,this.vertexTypes[e][s]===1&&t.rotate120(this.m,this.n),o.push(t.clone());this.isoVecsBAOA.push(o)}}MapToFace(t,e){const o=this.IDATA.face[t],s=o[2],i=o[1],n=o[0],r=I.FromArray(this.IDATA.vertex[s]),h=I.FromArray(this.IDATA.vertex[i]),f=I.FromArray(this.IDATA.vertex[n]),y=h.subtract(r),g=f.subtract(r),x=y.scale(this.coau).add(g.scale(this.cobu)),w=y.scale(this.coav).add(g.scale(this.cobv));let A,B=N.Vector3[0];for(let u=0;u<this.cartesian.length;u++)B=x.scale(this.cartesian[u].x).add(w.scale(this.cartesian[u].y)).add(r),B.x,B.y,B.z,A=t+"|"+this.vertices[u].x+"|"+this.vertices[u].y,e.vertex[this.vecToidx[A]]=[B.x,B.y,B.z]}build(t,e){const o=new Array,s=v.Zero(),i=new v(t,e),n=new v(-e,t+e);o.push(s,i,n);for(let a=e;a<t+1;a++)for(let c=0;c<t+1-a;c++)o.push(new v(c,a));if(e>0){const a=S.HCF(t,e),c=t/a,V=e/a;for(let d=1;d<a;d++)o.push(new v(d*c,d*V)),o.push(new v(-d*V,d*(c+V))),o.push(new v(t-d*(c+V),e+d*c));const z=t/e;for(let d=1;d<e;d++)for(let F=0;F<d*z;F++)o.push(new v(F,d)),o.push(new v(F,d).rotate120(t,e)),o.push(new v(F,d).rotateNeg120(t,e))}o.sort((a,c)=>a.x-c.x),o.sort((a,c)=>a.y-c.y);const r=new Array(t+e+1),h=new Array(t+e+1);for(let a=0;a<r.length;a++)r[a]=1/0,h[a]=-1/0;let f=0,y=0;const g=o.length;for(let a=0;a<g;a++)y=o[a].x,f=o[a].y,r[f]=Math.min(y,r[f]),h[f]=Math.max(y,h[f]);const x=(a,c)=>{const V=a.clone();return c==="A"&&V.rotateNeg120(t,e),c==="B"&&V.rotate120(t,e),V.x<0?V.y:V.x+V.y},w=[],A=[],B=[],u=[],D={},O=[];let b=-1,l=-1;for(let a=0;a<g;a++)w[a]=o[a].toCartesianOrigin(new v(0,0),.5),A[a]=x(o[a],"O"),B[a]=x(o[a],"A"),u[a]=x(o[a],"B"),A[a]===B[a]&&B[a]===u[a]?(b=3,l=A[a]):A[a]===B[a]?(b=4,l=A[a]):B[a]===u[a]?(b=5,l=B[a]):u[a]===A[a]&&(b=6,l=A[a]),A[a]<B[a]&&A[a]<u[a]&&(b=2,l=A[a]),B[a]<A[a]&&B[a]<u[a]&&(b=1,l=B[a]),u[a]<B[a]&&u[a]<A[a]&&(b=0,l=u[a]),O.push([b,l,o[a].x,o[a].y]);O.sort((a,c)=>a[2]-c[2]),O.sort((a,c)=>a[3]-c[3]),O.sort((a,c)=>a[1]-c[1]),O.sort((a,c)=>a[0]-c[0]);for(let a=0;a<O.length;a++)D[O[a][2]+"|"+O[a][3]]=[O[a][0],O[a][1],a];return this.m=t,this.n=e,this.vertices=o,this.vertByDist=D,this.cartesian=w,this.min=r,this.max=h,this}}class Z{constructor(t,e,o,s){this.name=t,this.category=e,this.vertex=o,this.face=s}}class P extends Z{innerToData(t,e){for(let o=0;o<e.innerFacets.length;o++)this.face.push(e.innerFacets[o].map(s=>e.vecToidx[t+s]))}mapABOBtoDATA(t,e){const o=e.IDATA.edgematch[t][0];for(let s=0;s<e.isoVecsABOB.length;s++){const i=[];for(let n=0;n<3;n++)e.vertexTypes[s][n]===0?i.push(t+"|"+e.isoVecsABOB[s][n].x+"|"+e.isoVecsABOB[s][n].y):i.push(o+"|"+e.isoVecsABOB[s][n].x+"|"+e.isoVecsABOB[s][n].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}mapOBOAtoDATA(t,e){const o=e.IDATA.edgematch[t][0];for(let s=0;s<e.isoVecsOBOA.length;s++){const i=[];for(let n=0;n<3;n++)e.vertexTypes[s][n]===1?i.push(t+"|"+e.isoVecsOBOA[s][n].x+"|"+e.isoVecsOBOA[s][n].y):i.push(o+"|"+e.isoVecsOBOA[s][n].x+"|"+e.isoVecsOBOA[s][n].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}mapBAOAtoDATA(t,e){const o=e.IDATA.edgematch[t][2];for(let s=0;s<e.isoVecsBAOA.length;s++){const i=[];for(let n=0;n<3;n++)e.vertexTypes[s][n]===1?i.push(t+"|"+e.isoVecsBAOA[s][n].x+"|"+e.isoVecsBAOA[s][n].y):i.push(o+"|"+e.isoVecsBAOA[s][n].x+"|"+e.isoVecsBAOA[s][n].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}orderData(t){const e=[];for(let n=0;n<13;n++)e[n]=[];const o=t.closestTo;for(let n=0;n<o.length;n++)o[n][0]>-1?o[n][1]>0&&e[o[n][0]].push([n,o[n][1]]):e[12].push([n,o[n][0]]);const s=[];for(let n=0;n<12;n++)s[n]=n;let i=12;for(let n=0;n<12;n++){e[n].sort((r,h)=>r[1]-h[1]);for(let r=0;r<e[n].length;r++)s[e[n][r][0]]=i++}for(let n=0;n<e[12].length;n++)s[e[12][n][0]]=i++;for(let n=0;n<this.vertex.length;n++)this.vertex[n].push(s[n]);this.vertex.sort((n,r)=>n[3]-r[3]);for(let n=0;n<this.vertex.length;n++)this.vertex[n].pop();for(let n=0;n<this.face.length;n++)for(let r=0;r<this.face[n].length;r++)this.face[n][r]=s[this.face[n][r]];this.sharedNodes=e[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(t,e){const o=[],s=[];let i=e.pop();s.push(i);let n=this.face[i].indexOf(t);n=(n+2)%3;let r=this.face[i][n];o.push(r);let h=0;for(;e.length>0;)i=e[h],this.face[i].indexOf(r)>-1?(n=(this.face[i].indexOf(r)+1)%3,r=this.face[i][n],o.push(r),s.push(i),e.splice(h,1),h=0):h++;return this.adjacentFaces.push(o),s}toGoldbergPolyhedronData(){const t=new Z("GeoDual","Goldberg",[],[]);t.name="GD dual";const e=this.vertex.length,o=new Array(e);for(let f=0;f<e;f++)o[f]=[];for(let f=0;f<this.face.length;f++)for(let y=0;y<3;y++)o[this.face[f][y]].push(f);let s=0,i=0,n=0,r=[],h=[];this.adjacentFaces=[];for(let f=0;f<o.length;f++)t.face[f]=this.setOrder(f,o[f].concat([])),o[f].forEach(y=>{s=0,i=0,n=0,r=this.face[y];for(let g=0;g<3;g++)h=this.vertex[r[g]],s+=h[0],i+=h[1],n+=h[2];t.vertex[y]=[s/3,i/3,n/3]});return t}static BuildGeodesicData(t){const e=new P("Geodesic-m-n","Geodesic",[[0,p,-1],[-p,1,0],[-1,0,-p],[1,0,-p],[p,1,0],[0,p,1],[-1,0,p],[-p,-1,0],[0,-p,-1],[p,-1,0],[1,0,p],[0,-p,1]],[]);t.setIndices(),t.calcCoeffs(),t.createInnerFacets(),t.edgeVecsABOB(),t.mapABOBtoOBOA(),t.mapABOBtoBAOA();for(let s=0;s<t.IDATA.face.length;s++)t.MapToFace(s,e),e.innerToData(s,t),t.IDATA.edgematch[s][1]==="B"&&e.mapABOBtoDATA(s,t),t.IDATA.edgematch[s][1]==="O"&&e.mapOBOAtoDATA(s,t),t.IDATA.edgematch[s][3]==="A"&&e.mapBAOAtoDATA(s,t);e.orderData(t);const o=1;return e.vertex=e.vertex.map(function(s){const i=s[0],n=s[1],r=s[2],h=Math.sqrt(i*i+n*n+r*r);return s[0]*=o/h,s[1]*=o/h,s[2]*=o/h,s}),e}}function ge(M,t,e=null){let o=t.m||1;o!==Math.floor(o)&&T.Warn("m not an integer only floor(m) used");let s=t.n||0;if(s!==Math.floor(s)&&T.Warn("n not an integer only floor(n) used"),s>o){const f=s;s=o,o=f,T.Warn("n > m therefore m and n swapped")}const i=new W;i.build(o,s);const r={custom:P.BuildGeodesicData(i),size:t.size,sizeX:t.sizeX,sizeY:t.sizeY,sizeZ:t.sizeZ,faceUV:t.faceUV,faceColors:t.faceColors,flat:t.flat,updatable:t.updatable,sideOrientation:t.sideOrientation,frontUVs:t.frontUVs,backUVs:t.backUVs};return U(M,r,e)}function Oe(M,t){const e=M.size,o=M.sizeX||e||1,s=M.sizeY||e||1,i=M.sizeZ||e||1,n=M.sideOrientation===0?0:M.sideOrientation||j.DEFAULTSIDE,r=new Array,h=new Array,f=new Array,y=new Array;let g=1/0,x=-1/0,w=1/0,A=-1/0;for(let D=0;D<t.vertex.length;D++)g=Math.min(g,t.vertex[D][0]*o),x=Math.max(x,t.vertex[D][0]*o),w=Math.min(w,t.vertex[D][1]*s),A=Math.max(A,t.vertex[D][1]*s);let B=0;for(let D=0;D<t.face.length;D++){const O=t.face[D],b=I.FromArray(t.vertex[O[0]]),l=I.FromArray(t.vertex[O[2]]),a=I.FromArray(t.vertex[O[1]]),c=l.subtract(b),V=a.subtract(b),z=I.Cross(V,c).normalize();for(let d=0;d<O.length;d++){f.push(z.x,z.y,z.z);const F=t.vertex[O[d]];r.push(F[0]*o,F[1]*s,F[2]*i);const C=(F[1]*s-w)/(A-w);y.push((F[0]*o-g)/(x-g),R.UseOpenGLOrientationForUV?1-C:C)}for(let d=0;d<O.length-2;d++)h.push(B,B+d+2,B+d+1);B+=O.length}j._ComputeSides(n,r,h,f,y);const u=new j;return u.positions=r,u.indices=h,u.normals=f,u.uvs=y,u}function ve(M,t,e=null){const o=t.size,s=t.sizeX||o||1,i=t.sizeY||o||1,n=t.sizeZ||o||1;let r=t.m||1;r!==Math.floor(r)&&T.Warn("m not an integer only floor(m) used");let h=t.n||0;if(h!==Math.floor(h)&&T.Warn("n not an integer only floor(n) used"),h>r){const A=h;h=r,r=A,T.Warn("n > m therefore m and n swapped")}const f=new W;f.build(r,h);const y=P.BuildGeodesicData(f),g=y.toGoldbergPolyhedronData(),x=new X(M,e);t.sideOrientation=Y._GetDefaultSideOrientation(t.sideOrientation),x._originalBuilderSideOrientation=t.sideOrientation,Oe(t,g).applyToMesh(x,t.updatable),x.goldbergData.nbSharedFaces=y.sharedNodes,x.goldbergData.nbUnsharedFaces=y.poleNodes,x.goldbergData.adjacentFaces=y.adjacentFaces,x.goldbergData.nbFaces=x.goldbergData.nbSharedFaces+x.goldbergData.nbUnsharedFaces,x.goldbergData.nbFacesAtPole=(x.goldbergData.nbUnsharedFaces-12)/12;for(let A=0;A<y.vertex.length;A++)x.goldbergData.faceCenters.push(I.FromArray(y.vertex[A])),x.goldbergData.faceCenters[A].x*=s,x.goldbergData.faceCenters[A].y*=i,x.goldbergData.faceCenters[A].z*=n,x.goldbergData.faceColors.push(new E(1,1,1,1));for(let A=0;A<g.face.length;A++){const B=g.face[A],u=I.FromArray(g.vertex[B[0]]),D=I.FromArray(g.vertex[B[2]]),O=I.FromArray(g.vertex[B[1]]),b=D.subtract(u),l=O.subtract(u),a=I.Cross(l,b).normalize(),c=I.Cross(l,a).normalize();x.goldbergData.faceXaxis.push(l.normalize()),x.goldbergData.faceYaxis.push(a),x.goldbergData.faceZaxis.push(c)}return x}const De={CreateBox:q,CreateTiledBox:H,CreateSphere:k,CreateDisc:K,CreateIcoSphere:J,CreateRibbon:Q,CreateCylinder:_,CreateTorus:$,CreateTorusKnot:ee,CreateLineSystem:te,CreateLines:se,CreateDashedLines:oe,ExtrudeShape:ne,ExtrudeShapeCustom:ae,CreateLathe:ie,CreateTiledPlane:re,CreatePlane:ce,CreateGround:he,CreateTiledGround:le,CreateGroundFromHeightMap:fe,CreatePolygon:de,ExtrudePolygon:xe,CreateTube:Ae,CreatePolyhedron:U,CreateGeodesic:ge,CreateGoldberg:ve,CreateDecal:ue,CreateCapsule:ye,CreateText:Be};export{ge as C,P as G,De as M,Z as P,W as _,ve as a,Oe as b};
